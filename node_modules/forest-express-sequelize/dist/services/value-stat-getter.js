"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _forestExpress = require("forest-express");

var _lodash = _interopRequireDefault(require("lodash"));

var _operators = _interopRequireDefault(require("../utils/operators"));

var _orm = _interopRequireDefault(require("../utils/orm"));

var _filtersParser = _interopRequireDefault(require("./filters-parser"));

var _queryOptions = _interopRequireDefault(require("./query-options"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

class ValueStatGetter {
  constructor(model, params, options) {
    this._model = model;
    this._params = params;
    this._options = options;
    this._OPERATORS = _operators.default.getInstance(options);
    this._schema = _forestExpress.Schemas.schemas[model.name];
    this._operatorDateParser = new _forestExpress.BaseOperatorDateParser({
      operators: this._OPERATORS,
      timezone: params.timezone
    });
  }
  /** Function used to aggregate results (count, sum, ...) */


  get _aggregateFunction() {
    return this._params.aggregate.toLowerCase();
  }
  /** Column name we're aggregating on */


  get _aggregateField() {
    // NOTICE: As MySQL cannot support COUNT(table_name.*) syntax, fieldName cannot be '*'.
    const fieldName = this._params.aggregate_field || this._schema.primaryKeys[0] || this._schema.fields[0].field;
    return `${this._schema.name}.${_orm.default.getColumnName(this._schema, fieldName)}`;
  }

  async perform() {
    const {
      filters,
      timezone
    } = this._params;
    const queryOptions = new _queryOptions.default(this._model, {
      includeRelations: true
    });
    await queryOptions.filterByConditionTree(filters, timezone); // No attributes should be retrieved from relations for the group by to work.

    const options = queryOptions.sequelizeOptions;
    options.include = options.include ? options.include.map(function (includeProperties) {
      return _objectSpread(_objectSpread({}, includeProperties), {}, {
        attributes: []
      });
    }) : undefined;
    return {
      value: await _bluebird.default.props({
        countCurrent: this._getCount(options),
        countPrevious: this._getCountPrevious(options)
      })
    };
  }

  async _getCount(options) {
    const count = await this._model.unscoped().aggregate(this._aggregateField, this._aggregateFunction, options); // sequelize@4 returns NaN, while sequelize@5+ returns null

    return count || 0;
  }
  /**
   * Fetch the value for the previous period.
   *
   * FIXME Will not work on edges cases
   * - when the 'rawPreviousInterval.field' appears twice
   * - when scopes use the same field as the filter
   */


  async _getCountPrevious(options) {
    const {
      filters,
      timezone
    } = this._params;

    if (!filters) {
      return undefined;
    }

    const conditionsParser = new _filtersParser.default(this._schema, timezone, this._options);
    const rawInterval = conditionsParser.getPreviousIntervalCondition(filters);

    if (!rawInterval) {
      return undefined;
    }

    const interval = this._operatorDateParser.getPreviousDateFilter(rawInterval.operator, rawInterval.value);

    const newOptions = _lodash.default.cloneDeepWith(options, function (object) {
      return object && object[rawInterval.field] ? _objectSpread(_objectSpread({}, object), {}, {
        [rawInterval.field]: interval
      }) : undefined;
    });

    return this._getCount(newOptions);
  }

}

module.exports = ValueStatGetter;