"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.promise");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _forestExpress = require("forest-express");

var _lodash = _interopRequireDefault(require("lodash"));

var _moment = _interopRequireDefault(require("moment"));

var _database = require("../utils/database");

var _orm = _interopRequireWildcard(require("../utils/orm"));

var _queryOptions = _interopRequireDefault(require("./query-options"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// NOTICE: These aliases are not camelcased to prevent issues with Sequelize.
const ALIAS_GROUP_BY = 'forest_alias_groupby';
const ALIAS_AGGREGATE = 'forest_alias_aggregate';

function PieStatGetter(model, params, options) {
  const needsDateOnlyFormating = (0, _orm.isVersionLessThan)(options.Sequelize, '4.0.0');
  const schema = _forestExpress.Schemas.schemas[model.name];
  let associationSplit;
  let associationCollection;
  let associationField;
  let associationSchema;
  let field;

  if (params.group_by_field.indexOf(':') === -1) {
    field = _lodash.default.find(schema.fields, function (currentField) {
      return currentField.field === params.group_by_field;
    });
  } else {
    associationSplit = params.group_by_field.split(':');
    associationCollection = model.associations[associationSplit[0]].target.name;
    [, associationField] = associationSplit;
    associationSchema = _forestExpress.Schemas.schemas[associationCollection];
    field = _lodash.default.find(associationSchema.fields, function (currentField) {
      return currentField.field === associationField;
    });
  }

  function getGroupByField() {
    if (params.group_by_field.includes(':')) {
      const [associationName, fieldName] = params.group_by_field.split(':');
      return `${associationName}.${_orm.default.getColumnName(associationSchema, fieldName)}`;
    }

    return `${schema.name}.${_orm.default.getColumnName(schema, params.group_by_field)}`;
  }

  const groupByField = getGroupByField();

  function getAggregate() {
    return params.aggregate.toLowerCase();
  }

  function getAggregateField() {
    // NOTICE: As MySQL cannot support COUNT(table_name.*) syntax, fieldName cannot be '*'.
    const fieldName = params.aggregate_field || schema.primaryKeys[0] || schema.fields[0].field;
    return `${schema.name}.${_orm.default.getColumnName(schema, fieldName)}`;
  }

  function getGroupBy() {
    return (0, _database.isMSSQL)(model.sequelize) ? [options.Sequelize.col(groupByField)] : [ALIAS_GROUP_BY];
  }

  function formatResults(records) {
    return records.map(function (record) {
      let key;

      if (field.type === 'Date') {
        key = (0, _moment.default)(record[ALIAS_GROUP_BY]).format('DD/MM/YYYY HH:mm:ss');
      } else if (field.type === 'Dateonly' && needsDateOnlyFormating) {
        const offsetServer = (0, _moment.default)().utcOffset() / 60;

        const dateonly = _moment.default.utc(record[ALIAS_GROUP_BY]).add(offsetServer, 'h');

        key = dateonly.format('DD/MM/YYYY');
      } else {
        key = String(record[ALIAS_GROUP_BY]);
      }

      return {
        key,
        value: record[ALIAS_AGGREGATE]
      };
    });
  }

  this.perform = async function () {
    const {
      filters,
      timezone
    } = params;
    const queryOptions = new _queryOptions.default(model, {
      includeRelations: true
    });
    await queryOptions.filterByConditionTree(filters, timezone);

    const sequelizeOptions = _objectSpread(_objectSpread({}, queryOptions.sequelizeOptions), {}, {
      attributes: [[options.Sequelize.col(groupByField), ALIAS_GROUP_BY], [options.Sequelize.fn(getAggregate(), options.Sequelize.col(getAggregateField())), ALIAS_AGGREGATE]],
      group: getGroupBy(),
      order: [[options.Sequelize.literal(ALIAS_AGGREGATE), 'DESC']],
      raw: true
    });

    if (sequelizeOptions.include) {
      sequelizeOptions.include = sequelizeOptions.include.map(function (includeProperties) {
        return _objectSpread(_objectSpread({}, includeProperties), {}, {
          attributes: []
        });
      });
    }

    const records = await model.unscoped().findAll(sequelizeOptions);
    return {
      value: formatResults(records)
    };
  };
}

module.exports = PieStatGetter;