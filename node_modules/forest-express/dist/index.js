"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var _ = require('lodash');

var express = require('express');

var cors = require('cors');

var bodyParser = require('body-parser');

var jwt = require('express-jwt');

var url = require('url');

var requireAll = require('require-all');

var context = require('./context');

var initContext = require('./context/init');

context.init(initContext);

var auth = require('./services/auth');

var ResourcesRoutes = require('./routes/resources');

var ActionsRoutes = require('./routes/actions');

var AssociationsRoutes = require('./routes/associations');

var StatRoutes = require('./routes/stats');

var ForestRoutes = require('./routes/forest');

var HealthCheckRoute = require('./routes/healthcheck');

var Schemas = require('./generators/schemas');

var SchemaSerializer = require('./serializers/schema');

var Integrator = require('./integrations');

var _require = require('./config/jwt'),
    getJWTConfiguration = _require.getJWTConfiguration;

var initAuthenticationRoutes = require('./routes/authentication');

var _context$inject = context.inject(),
    logger = _context$inject.logger,
    path = _context$inject.path,
    pathService = _context$inject.pathService,
    errorHandler = _context$inject.errorHandler,
    ipWhitelist = _context$inject.ipWhitelist,
    apimapFieldsFormater = _context$inject.apimapFieldsFormater,
    apimapSender = _context$inject.apimapSender,
    schemaFileUpdater = _context$inject.schemaFileUpdater,
    configStore = _context$inject.configStore,
    modelsManager = _context$inject.modelsManager,
    fs = _context$inject.fs,
    tokenService = _context$inject.tokenService;

var PUBLIC_ROUTES = ['/', '/healthcheck'].concat((0, _toConsumableArray2["default"])(initAuthenticationRoutes.PUBLIC_ROUTES));
var ENVIRONMENT_DEVELOPMENT = !process.env.NODE_ENV || ['dev', 'development'].includes(process.env.NODE_ENV);
var DISABLE_AUTO_SCHEMA_APPLY = process.env.FOREST_DISABLE_AUTO_SCHEMA_APPLY && JSON.parse(process.env.FOREST_DISABLE_AUTO_SCHEMA_APPLY);
var jwtAuthenticator;
var app = null;

function loadCollections(collectionsDir) {
  var isJavascriptOrTypescriptFileName = function isJavascriptOrTypescriptFileName(fileName) {
    return fileName.endsWith('.js') || fileName.endsWith('.ts') && !fileName.endsWith('.d.ts');
  }; // NOTICE: Ends with `.spec.js`, `.spec.ts`, `.test.js` or `.test.ts`.


  var isTestFileName = function isTestFileName(fileName) {
    return fileName.match(/(?:\.test|\.spec)\.(?:js||ts)$/g);
  };

  requireAll({
    dirname: collectionsDir,
    excludeDirs: /^__tests__$/,
    filter: function filter(fileName) {
      return isJavascriptOrTypescriptFileName(fileName) && !isTestFileName(fileName);
    },
    recursive: true
  });
}

function buildSchema() {
  return _buildSchema.apply(this, arguments);
}

function _buildSchema() {
  _buildSchema = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
    var lianaOptions, Implementation, models;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            lianaOptions = configStore.lianaOptions, Implementation = configStore.Implementation;
            models = Object.values(modelsManager.getModels());
            configStore.integrator = new Integrator(lianaOptions, Implementation);
            _context2.next = 5;
            return Schemas.perform(Implementation, configStore.integrator, models, lianaOptions);

          case 5:
            return _context2.abrupt("return", models);

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _buildSchema.apply(this, arguments);
}

exports.Schemas = Schemas;
exports.logger = logger;
exports.ResourcesRoute = {};
/**
 * @param {import('express').Request} request
 * @param {import('express').Response} response
 * @param {import('express').NextFunction} next
 */

exports.ensureAuthenticated = function (request, response, next) {
  var parsedUrl = url.parse(request.originalUrl);
  var forestPublicRoutes = PUBLIC_ROUTES.map(function (route) {
    return "/forest".concat(route);
  });

  if (forestPublicRoutes.includes(parsedUrl.pathname)) {
    next();
    return;
  }

  auth.authenticate(request, response, next, jwtAuthenticator);
};

function generateAndSendSchema(envSecret) {
  var collections = _.values(Schemas.schemas);

  configStore.integrator.defineCollections(collections);
  collections.filter(function (collection) {
    return collection.actions && collection.actions.length;
  }) // NOTICE: Check each Smart Action declaration to detect configuration errors.
  .forEach(function (collection) {
    var isFieldsInvalid = function isFieldsInvalid(action) {
      return action.fields && !Array.isArray(action.fields);
    };

    collection.actions.forEach(function (action) {
      if (!action.name) {
        logger.warn("An unnamed Smart Action of collection \"".concat(collection.name, "\" has been ignored."));
      } else if (isFieldsInvalid(action)) {
        logger.error("Cannot find the fields you defined for the Smart action \"".concat(action.name, "\" of your \"").concat(collection.name, "\" collection. The fields option must be an array."));
      }
    }); // NOTICE: Ignore actions without a name.

    collection.actions = collection.actions.filter(function (action) {
      return action.name;
    });
  });
  var schemaSerializer = new SchemaSerializer();
  var serializerOptions = schemaSerializer.options;
  var collectionsSent;
  var metaSent;
  var pathSchemaFile = path.join(configStore.schemaDir, '.forestadmin-schema.json');

  if (ENVIRONMENT_DEVELOPMENT) {
    var meta = {
      liana: configStore.Implementation.getLianaName(),
      liana_version: configStore.Implementation.getLianaVersion(),
      stack: {
        database_type: configStore.Implementation.getDatabaseType(),
        engine: 'nodejs',
        engine_version: process.versions && process.versions.node,
        orm_version: configStore.Implementation.getOrmVersion()
      }
    };
    var content = schemaFileUpdater.update(pathSchemaFile, collections, meta, serializerOptions);
    collectionsSent = content.collections;
    metaSent = content.meta;
  } else {
    try {
      var _content = fs.readFileSync(pathSchemaFile);

      if (!_content) {
        logger.error('The .forestadmin-schema.json file is empty.');
        logger.error('The schema cannot be synchronized with Forest Admin servers.');
        return;
      }

      var contentParsed = JSON.parse(_content.toString());
      collectionsSent = contentParsed.collections;
      metaSent = contentParsed.meta;
    } catch (error) {
      if (error.code === 'ENOENT') {
        logger.error('The .forestadmin-schema.json file does not exist.');
      } else {
        logger.error('The content of .forestadmin-schema.json file is not a correct JSON.');
      }

      logger.error('The schema cannot be synchronized with Forest Admin servers.');
      return;
    }
  }

  if (DISABLE_AUTO_SCHEMA_APPLY) {
    return;
  }

  var schemaSent = schemaSerializer.perform(collectionsSent, metaSent);
  apimapSender.send(envSecret, schemaSent);
}

exports.init = /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(Implementation) {
    var opts, pathMounted, allowedOrigins, oneDayInSeconds, corsOptions, pathsPublic, models, collections;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            opts = Implementation.opts;
            configStore.Implementation = Implementation;
            configStore.lianaOptions = opts;

            if (!app) {
              _context.next = 6;
              break;
            }

            logger.warn('Forest init function called more than once. Only the first call has been processed.');
            return _context.abrupt("return", app);

          case 6:
            app = express();
            _context.prev = 7;
            configStore.validateOptions();
            _context.next = 15;
            break;

          case 11:
            _context.prev = 11;
            _context.t0 = _context["catch"](7);
            logger.error(_context.t0.message);
            return _context.abrupt("return", Promise.resolve(app));

          case 15:
            pathMounted = pathService.generateForInit('*', configStore.lianaOptions);
            auth.initAuth(configStore.lianaOptions); // CORS

            allowedOrigins = ['localhost:4200', /\.forestadmin\.com$/];
            oneDayInSeconds = 86400;

            if (process.env.CORS_ORIGINS) {
              allowedOrigins = allowedOrigins.concat(process.env.CORS_ORIGINS.split(','));
            }

            corsOptions = {
              origin: allowedOrigins,
              maxAge: oneDayInSeconds,
              credentials: true,
              preflightContinue: true
            };
            app.use(pathService.generate(initAuthenticationRoutes.CALLBACK_ROUTE, opts), cors(_objectSpread(_objectSpread({}, corsOptions), {}, {
              // this route needs to be called after a redirection
              // in this situation, the origin sent by the browser is "null"
              origin: ['null'].concat((0, _toConsumableArray2["default"])(corsOptions.origin))
            })));
            app.use(pathMounted, cors(corsOptions)); // Mime type

            app.use(pathMounted, bodyParser.json()); // Authentication

            if (configStore.lianaOptions.authSecret) {
              jwtAuthenticator = jwt(getJWTConfiguration({
                secret: configStore.lianaOptions.authSecret,
                getToken: function getToken(request) {
                  if (request.headers) {
                    if (request.headers.authorization && request.headers.authorization.split(' ')[0] === 'Bearer') {
                      return request.headers.authorization.split(' ')[1];
                    } // NOTICE: Necessary for downloads authentication.


                    if (request.headers.cookie) {
                      var forestSessionToken = tokenService.extractForestSessionToken(request.headers.cookie);

                      if (forestSessionToken) {
                        return forestSessionToken;
                      }
                    }
                  }

                  return null;
                }
              }));
            }

            if (jwtAuthenticator) {
              pathsPublic = [/^\/forest\/authentication$/, /^\/forest\/authentication\/.*$/];
              app.use(pathMounted, jwtAuthenticator.unless({
                path: pathsPublic
              }));
            }

            new HealthCheckRoute(app, configStore.lianaOptions).perform();
            initAuthenticationRoutes(app, configStore.lianaOptions, context.inject()); // Init

            _context.prev = 28;
            _context.next = 31;
            return buildSchema();

          case 31:
            models = _context.sent;

            if (configStore.doesConfigDirExist()) {
              loadCollections(configStore.configDir);
            }

            models.forEach(function (model) {
              var modelName = configStore.Implementation.getModelName(model);
              configStore.integrator.defineRoutes(app, model, configStore.Implementation);
              var resourcesRoute = new ResourcesRoutes(app, model);
              resourcesRoute.perform();
              exports.ResourcesRoute[modelName] = resourcesRoute;
              new AssociationsRoutes(app, model, configStore.Implementation, configStore.integrator, configStore.lianaOptions).perform();
              new StatRoutes(app, model, configStore.Implementation, configStore.lianaOptions).perform();
            });
            collections = _.values(Schemas.schemas);
            collections.forEach(function (collection) {
              var retrievedModel = models.find(function (model) {
                return configStore.Implementation.getModelName(model) === collection.name;
              });
              new ActionsRoutes().perform(app, collection, retrievedModel, configStore.Implementation, configStore.lianaOptions, auth);
            });
            new ForestRoutes(app, configStore.lianaOptions).perform();
            app.use(pathMounted, errorHandler({
              logger: logger
            }));
            generateAndSendSchema(configStore.lianaOptions.envSecret);
            _context.prev = 39;
            _context.next = 42;
            return ipWhitelist.retrieve(configStore.lianaOptions.envSecret);

          case 42:
            _context.next = 46;
            break;

          case 44:
            _context.prev = 44;
            _context.t1 = _context["catch"](39);

          case 46:
            if (configStore.lianaOptions.expressParentApp) {
              configStore.lianaOptions.expressParentApp.use('/forest', app);
            }

            return _context.abrupt("return", app);

          case 50:
            _context.prev = 50;
            _context.t2 = _context["catch"](28);
            logger.error('An error occured while computing the Forest schema. Your application schema cannot be synchronized with Forest. Your admin panel might not reflect your application models definition. ', _context.t2);
            throw _context.t2;

          case 54:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[7, 11], [28, 50], [39, 44]]);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.collection = function (name, opts) {
  if (_.isEmpty(Schemas.schemas) && opts.modelsDir) {
    logger.error("Cannot customize your collection named \"".concat(name, "\" properly. Did you call the \"collection\" method in the /forest directory?"));
    return;
  }

  var collection = _.find(Schemas.schemas, {
    name: name
  });

  if (!collection) {
    collection = _.find(Schemas.schemas, {
      nameOld: name
    });

    if (collection) {
      name = collection.name;
      logger.warn("DEPRECATION WARNING: Collection names are now based on the models names. Please rename the collection \"".concat(collection.nameOld, "\" of your Forest customisation in \"").concat(collection.name, "\"."));
    }
  }

  if (collection) {
    if (!Schemas.schemas[name].actions) {
      Schemas.schemas[name].actions = [];
    }

    if (!Schemas.schemas[name].segments) {
      Schemas.schemas[name].segments = [];
    }

    Schemas.schemas[name].actions = _.union(opts.actions, Schemas.schemas[name].actions);
    Schemas.schemas[name].segments = _.union(opts.segments, Schemas.schemas[name].segments); // NOTICE: Smart Field definition case

    opts.fields = apimapFieldsFormater.formatFieldsByCollectionName(opts.fields, name);
    Schemas.schemas[name].fields = _.concat(opts.fields, Schemas.schemas[name].fields);

    if (opts.searchFields) {
      Schemas.schemas[name].searchFields = opts.searchFields;
    }
  } else if (opts.fields && opts.fields.length) {
    // NOTICE: Smart Collection definition case
    opts.name = name;
    opts.idField = 'id';
    opts.isVirtual = true;
    opts.isSearchable = !!opts.isSearchable;
    opts.fields = apimapFieldsFormater.formatFieldsByCollectionName(opts.fields, name);
    Schemas.schemas[name] = opts;
  }
};

exports.SchemaSerializer = SchemaSerializer;
exports.StatSerializer = require('./serializers/stat');
exports.ResourceSerializer = require('./serializers/resource');
exports.ResourceDeserializer = require('./deserializers/resource');
exports.BaseFiltersParser = require('./services/base-filters-parser');
exports.BaseOperatorDateParser = require('./services/base-operator-date-parser');
exports.RecordsGetter = require('./services/exposed/records-getter');
exports.RecordsCounter = require('./services/exposed/records-counter');
exports.RecordsExporter = require('./services/exposed/records-exporter');
exports.RecordGetter = require('./services/exposed/record-getter');
exports.RecordUpdater = require('./services/exposed/record-updater');
exports.RecordCreator = require('./services/exposed/record-creator');
exports.RecordRemover = require('./services/exposed/record-remover');
exports.RecordsRemover = require('./services/exposed/records-remover');
exports.RecordSerializer = require('./services/exposed/record-serializer');
exports.PermissionMiddlewareCreator = require('./middlewares/permissions');
exports.errorHandler = errorHandler;
exports.PUBLIC_ROUTES = PUBLIC_ROUTES;